<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JPEG Text Editor</title>
  <style>
    body{font-family:system-ui,Arial;margin:12px;color:#111}
    #canvas-container{border:1px solid #ccc;display:inline-block}
    .controls{margin-bottom:8px}
    button,select,input[type=file]{margin-right:8px}
    #tools {margin-top:8px}
  </style>
</head>
<body>
  <div class="controls">
    <input id="file" type="file" accept="image/jpeg,image/png">
    <button id="runOCR">Run OCR & Extract Text</button>
    <select id="fontList">
      <option value="Arial">Arial</option>
      <option value="Times New Roman">Times New Roman</option>
      <option value="Calibri">Calibri</option>
      <option value="Georgia">Georgia</option>
      <option value="Verdana">Verdana</option>
      <option value="Courier New">Courier New</option>
    </select>
    <button id="deleteSelected">Delete Selected Text</button>
    <button id="clearSelection">Clear Selection</button>
    <button id="download">Download JPG</button>
  </div>
  <div id="tools">
    <label><input type="radio" name="mode" value="select" checked> Select/Resize</label>
    <label><input type="radio" name="mode" value="erase"> Erase Area</label>
  </div>
  <div id="canvas-container">
    <canvas id="c" width="900" height="600"></canvas>
  </div>

  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>

  <script>
    const canvas = new fabric.Canvas('c', { preserveObjectStacking:true });
    let baseImageObj = null;
    let mode = 'select';

    const file = document.getElementById('file');
    const runOCR = document.getElementById('runOCR');
    const fontList = document.getElementById('fontList');
    const deleteSelected = document.getElementById('deleteSelected');
    const download = document.getElementById('download');

    // Load image
    file.addEventListener('change', e=>{
      const f = e.target.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      fabric.Image.fromURL(url, img=>{
        const maxW = 1200, maxH = 800;
        let scale = Math.min(maxW / img.width, maxH / img.height, 1);
        img.set({left:0,top:0,selectable:false});
        img.scale(scale);
        canvas.clear();
        canvas.setWidth(img.getScaledWidth());
        canvas.setHeight(img.getScaledHeight());
        canvas.add(img);
        baseImageObj = img;
        canvas.sendToBack(img);
      }, {crossOrigin: 'anonymous'});
    });

    // OCR with Tesseract
    runOCR.addEventListener('click', async ()=>{
      if(!baseImageObj) return alert('Load an image first');
      const dataURL = canvas.toDataURL({format:'png'});
      runOCR.disabled = true;
      runOCR.textContent = 'OCR running...';
      try {
        const { data } = await Tesseract.recognize(dataURL, 'eng');
        data.words.forEach(w => {
          const { bbox: { x0, y0, x1, y1 }, text } = w;
          const boxW = x1 - x0;
          const boxH = y1 - y0;
          const scaleX = canvas.getWidth() / data.width;
          const scaleY = canvas.getHeight() / data.height;
          const left = x0 * scaleX;
          const top = y0 * scaleY;
          const fontSize = Math.max(10, boxH * Math.max(scaleX, scaleY));
          const txt = new fabric.Textbox(text.trim() || '.', {
            left, top,
            fontFamily: fontList.value,
            fontSize: fontSize,
            fill: '#000',
            selectable: true
          });
          txt.set({ width: boxW * scaleX });
          canvas.add(txt);
        });
      } catch(err){
        console.error(err);
        alert('OCR failed: ' + err.message);
      } finally {
        runOCR.disabled = false;
        runOCR.textContent = 'Run OCR & Extract Text';
      }
    });

    // Mode switching
    document.querySelectorAll('input[name="mode"]').forEach(r=>r.addEventListener('change', e=>{
      mode = e.target.value;
      if(mode === 'select'){
        canvas.selection = true;
        canvas.forEachObject(o=>o.selectable = o !== baseImageObj);
      } else {
        canvas.selection = false;
        canvas.forEachObject(o=>{ if(o !== baseImageObj) o.selectable = false; });
      }
    }));

    // Delete selected
    deleteSelected.addEventListener('click', ()=>{
      const active = canvas.getActiveObject();
      if(!active) return;
      if(Array.isArray(active)){
        active.forEach(o=>canvas.remove(o));
      } else canvas.remove(active);
    });

    // Font change
    fontList.addEventListener('change', ()=>{
      const active = canvas.getActiveObject();
      if(active && active.type === 'textbox'){
        active.set('fontFamily', fontList.value);
        canvas.renderAll();
      }
    });

    // Download JPG
    download.addEventListener('click', ()=>{
      canvas.discardActiveObject();
      canvas.renderAll();
      const dataURL = canvas.toDataURL({format:'jpeg', quality:0.92});
      const a = document.createElement('a');
      a.href = dataURL; a.download = 'edited.jpg'; a.click();
    });

    // Simple erase mode
    let isDown=false, startX=0, startY=0, rect=null;
    canvas.on('mouse:down', function(opt){
      if(mode !== 'erase') return;
      isDown = true;
      const pointer = canvas.getPointer(opt.e);
      startX = pointer.x; startY = pointer.y;
      rect = new fabric.Rect({ left:startX, top:startY, width:0, height:0, fill:'rgba(0,0,0,0.2)', selectable:false, evented:false });
      canvas.add(rect);
    });
    canvas.on('mouse:move', function(opt){
      if(!isDown || mode!=='erase') return;
      const pointer = canvas.getPointer(opt.e);
      rect.set({ width: Math.abs(pointer.x - startX), height: Math.abs(pointer.y - startY), left: Math.min(pointer.x, startX), top: Math.min(pointer.y, startY) });
      canvas.renderAll();
    });
    canvas.on('mouse:up', function(opt){
      if(!isDown || mode!=='erase') return;
      isDown=false;
      const r = rect.getBoundingRect();
      canvas.remove(rect);
      const patch = new fabric.Rect({ left:r.left, top:r.top, width:r.width, height:r.height, fill:'#fff', selectable:false, evented:false });
      canvas.add(patch);
      canvas.renderAll();
    });

    // Keyboard delete
    document.addEventListener('keydown', (e)=>{ 
      if(e.key==='Delete' || e.key==='Backspace'){ 
        const a = canvas.getActiveObject(); 
        if(a) canvas.remove(a); 
      } 
    });
  </script>
</body>
</html>
