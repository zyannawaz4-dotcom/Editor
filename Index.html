<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JPEG Text Editor (Fabric + Tesseract)</title>
  <style>
    body{font-family:system-ui,Arial;margin:12px;color:#111}
    #canvas-container{border:1px solid #ccc;display:inline-block}
    .controls{margin-bottom:8px}
    button,select,input[type=file]{margin-right:8px}
    #tools {margin-top:8px}
  </style>
</head>
<body>
  <div class="controls">
    <input id="file" type="file" accept="image/jpeg,image/png">
    <button id="runOCR">Run OCR & Extract Text</button>
    <select id="fontList">
      <option value="Arial">Arial</option>
      <option value="Times New Roman">Times New Roman</option>
      <option value="Calibri">Calibri</option>
      <option value="Georgia">Georgia</option>
      <option value="Verdana">Verdana</option>
      <option value="Courier New">Courier New</option>
    </select>
    <button id="deleteSelected">Delete Selected Text</button>
    <button id="clearSelection">Clear Selection</button>
    <button id="download">Download JPG</button>
  </div>  <div id="tools">
    <label><input type="radio" name="mode" value="select" checked> Select/Resize</label>
    <label><input type="radio" name="mode" value="erase"> Erase Area</label>
  </div>  <div id="canvas-container">
    <canvas id="c" width="900" height="600"></canvas>
  </div>  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.2.1/dist/tesseract.min.js"></script>  <script>
    const canvas = new fabric.Canvas('c', { preserveObjectStacking:true });
    let baseImageObj = null;
    let mode = 'select';
    const file = document.getElementById('file');
    const runOCR = document.getElementById('runOCR');
    const fontList = document.getElementById('fontList');
    const deleteSelected = document.getElementById('deleteSelected');
    const download = document.getElementById('download');

    // load image
    file.addEventListener('change', e=>{
      const f = e.target.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      fabric.Image.fromURL(url, img=>{
        const maxW = 1200, maxH = 800;
        let scale = Math.min(maxW / img.width, maxH / img.height, 1);
        img.set({left:0,top:0,selectable:false});
        img.scale(scale);
        canvas.clear();
        canvas.setWidth(img.getScaledWidth());
        canvas.setHeight(img.getScaledHeight());
        canvas.add(img);
        baseImageObj = img;
        canvas.sendToBack(img);
      }, {crossOrigin: 'anonymous'});
    });

    // OCR
    runOCR.addEventListener('click', async ()=>{
      if(!baseImageObj) return alert('Load an image first');
      const dataURL = canvas.toDataURL({format:'png'});
      runOCR.disabled = true;
      runOCR.textContent = 'OCR running...';
      try{
        const worker = Tesseract.createWorker();
        await worker.load();
        await worker.loadLanguage('eng');
        await worker.initialize('eng');
        const { data } = await worker.recognize(dataURL);
        // data.words contains bounding boxes
        data.words.forEach(w => {
          const { bbox: { x0, y0, x1, y1 }, text } = w;
          const boxW = x1 - x0;
          const boxH = y1 - y0;
          // scale returned coordinates to canvas size
          const scaleX = canvas.getWidth() / data.width;
          const scaleY = canvas.getHeight() / data.height;
          const left = x0 * scaleX;
          const top = y0 * scaleY;
          const fontSize = Math.max(10, boxH * Math.max(scaleX, scaleY));
          const txt = new fabric.Textbox(text.trim() || '.', {
            left, top,
            fontFamily: fontList.value,
            fontSize: fontSize,
            editable: true,
            fill: '#000000',
            backgroundColor: 'rgba(255,255,255,0)',
            selectable: true,
            objectCaching: false
          });
          // center text roughly in bbox by setting width
          txt.set({ width: boxW * scaleX });
          canvas.add(txt);
        });
        await worker.terminate();
      }catch(err){
        console.error(err); alert('OCR failed: ' + err.message);
      } finally{
        runOCR.disabled = false;
        runOCR.textContent = 'Run OCR & Extract Text';
      }
    });

    // mode switching
    document.querySelectorAll('input[name="mode"]').forEach(r=>r.addEventListener('change', e=>{
      mode = e.target.value;
      if(mode === 'select'){
        canvas.isDrawingMode = false;
        canvas.selection = true;
        canvas.forEachObject(o=>o.selectable = true && o !== baseImageObj);
      } else {
        // erase mode
        canvas.isDrawingMode = false;
        canvas.selection = false;
        canvas.forEachObject(o=>{ if(o !== baseImageObj) o.selectable = false; });
      }
    }));

    // delete selected
    deleteSelected.addEventListener('click', ()=>{
      const active = canvas.getActiveObject();
      if(!active) return;
      if(Array.isArray(active)){
        active.forEach(o=>canvas.remove(o));
      } else canvas.remove(active);
    });

    // font change applies to selected object or future objects
    fontList.addEventListener('change', ()=>{
      const active = canvas.getActiveObject();
      if(active && active.type === 'textbox'){
        active.set('fontFamily', fontList.value);
        canvas.renderAll();
      }
    });

    // download
    download.addEventListener('click', ()=>{
      // make background image not selectable
      canvas.discardActiveObject();
      canvas.renderAll();
      const dataURL = canvas.toDataURL({format:'jpeg', quality:0.92});
      const a = document.createElement('a');
      a.href = dataURL; a.download = 'edited.jpg'; a.click();
    });

    // Erase area implementation: drag to draw rect then fill with average surrounding color
    let isDown=false, startX=0, startY=0, rect=null;
    canvas.on('mouse:down', function(opt){
      if(mode !== 'erase') return;
      isDown = true;
      const pointer = canvas.getPointer(opt.e);
      startX = pointer.x; startY = pointer.y;
      rect = new fabric.Rect({ left:startX, top:startY, width:0, height:0, fill:'rgba(0,0,0,0.2)', selectable:false, evented:false });
      canvas.add(rect);
    });
    canvas.on('mouse:move', function(opt){
      if(!isDown || mode!=='erase') return;
      const pointer = canvas.getPointer(opt.e);
      rect.set({ width: Math.abs(pointer.x - startX), height: Math.abs(pointer.y - startY), left: Math.min(pointer.x, startX), top: Math.min(pointer.y, startY) });
      canvas.renderAll();
    });
    canvas.on('mouse:up', function(opt){
      if(!isDown || mode!=='erase') return;
      isDown=false;
      // get rect area and fill with average color from image around it
      const r = rect.getBoundingRect();
      canvas.remove(rect);
      performErase(Math.round(r.left), Math.round(r.top), Math.round(r.width), Math.round(r.height));
    });

    function performErase(x,y,w,h){
      if(!baseImageObj) return;
      // draw base image onto temp canvas and sample
      const tmp = document.createElement('canvas');
      tmp.width = canvas.getWidth(); tmp.height = canvas.getHeight();
      const ctx = tmp.getContext('2d');
      const imgEl = baseImageObj.getElement();
      // draw scaled image
      ctx.drawImage(imgEl, 0, 0, tmp.width, tmp.height);
      // sample border pixels around selection to estimate background color
      const samples = [];
      const sampleStep = 3;
      // top border
      for(let i=x;i<x+w;i+=sampleStep){ pushIfValid(i,y-1); }
      // bottom
      for(let i=x;i<x+w;i+=sampleStep){ pushIfValid(i,y+h+1); }
      // left
      for(let j=y;j<y+h;j+=sampleStep){ pushIfValid(x-1,j); }
      // right
      for(let j=y;j<y+h;j+=sampleStep){ pushIfValid(x+w+1,j); }
      function pushIfValid(px,py){ if(px<0||py<0||px>=tmp.width||py>=tmp.height) return; const d = ctx.getImageData(px,py,1,1).data; samples.push([d[0],d[1],d[2]]); }
      if(samples.length===0){ alert('Cannot sample area to erase. Try a different region.'); return; }
      // average
      const avg = samples.reduce((acc,p)=>{ acc[0]+=p[0]; acc[1]+=p[1]; acc[2]+=p[2]; return acc; }, [0,0,0]).map(v=>Math.round(v/samples.length));
      // create fabric rect filled with average color at given area and put on top of image
      const fillHex = 'rgb('+avg.join(',')+')';
      const patch = new fabric.Rect({ left:x, top:y, width:w, height:h, fill:fillHex, selectable:false, evented:false });
      canvas.add(patch);
      canvas.renderAll();
    }

    // keyboard delete
    document.addEventListener('keydown', (e)=>{ if(e.key==='Delete' || e.key==='Backspace'){ const a = canvas.getActiveObject(); if(a) canvas.remove(a); } });

    // keep controls working after object transforms
    canvas.on('object:modified', ()=>canvas.renderAll());

    // basic instructions overlay
    const instr = new fabric.Text('Load JPG -> Run OCR -> Edit text or switch to Erase to remove areas -> Resize text with handles -> Download', { left:10, top:10, fontSize:12, fill:'#444', selectable:false });
    instr.set({ backgroundColor:'rgba(255,255,255,0.6)' });
    // do not add instruction until canvas has image
    canvas.on('after:render', ()=>{});
  </script></body>
</html>
